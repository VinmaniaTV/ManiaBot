"use strict";
/**
 * YouTube Search
 * @author Snowflake107
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.YouTube = exports.Video = exports.Playlist = exports.Channel = exports.Thumbnail = exports.Util = void 0;
const Util_1 = __importDefault(require("./Util"));
exports.Util = Util_1.default;
const Channel_1 = __importDefault(require("./Structures/Channel"));
exports.Channel = Channel_1.default;
const Playlist_1 = __importDefault(require("./Structures/Playlist"));
exports.Playlist = Playlist_1.default;
const Video_1 = __importDefault(require("./Structures/Video"));
exports.Video = Video_1.default;
const Thumbnail_1 = __importDefault(require("./Structures/Thumbnail"));
exports.Thumbnail = Thumbnail_1.default;
const SAFE_SEARCH_COOKIE = "PREF=f2=8000000";
class YouTube {
    constructor() {
        throw new Error(`The ${this.constructor.name} class may not be instantiated!`);
    }
    static search(query, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!options)
                options = { limit: 20, type: "video", requestOptions: {} };
            if (!query || typeof query !== "string")
                throw new Error(`Invalid search query "${query}"!`);
            options.type = options.type || "video";
            const filter = options.type === "all" ? "" : `&sp=${Util_1.default.filter(options.type)}`;
            const url = `https://youtube.com/results?q=${encodeURI(query.trim())}&hl=en${filter}`;
            const requestOptions = options.safeSearch ? Object.assign(Object.assign({}, options.requestOptions), { headers: { cookie: SAFE_SEARCH_COOKIE } }) : {};
            const html = yield Util_1.default.getHTML(url, requestOptions);
            return Util_1.default.parseSearchResult(html, options);
        });
    }
    static searchOne(query, type, safeSearch, requestOptions) {
        if (!type)
            type = "video";
        return new Promise((resolve) => {
            // @ts-ignore
            YouTube.search(query, { limit: 1, type: type, requestOptions: requestOptions, safeSearch: !!safeSearch })
                .then(res => {
                if (!res || !res.length)
                    return resolve(null);
                resolve(res[0]);
            })
                .catch(() => {
                resolve(null);
            });
        });
    }
    /**
     * Returns playlist details
     * @param {string} url Playlist URL
     * @param {object} [options] Options
     * @param {number} [options.limit=100] Playlist video limit
     * @param {RequestInit} [options.requestOptions] Request Options
     */
    static getPlaylist(url, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!options)
                options = { limit: 100, requestOptions: {} };
            if (!url || typeof url !== "string")
                throw new Error(`Expected playlist url, received ${typeof url}!`);
            Util_1.default.validatePlaylist(url);
            url = Util_1.default.getPlaylistURL(url);
            const html = yield Util_1.default.getHTML(`${url}&hl=en`, options && options.requestOptions);
            return Util_1.default.getPlaylist(html, options && options.limit);
        });
    }
    /**
     * Returns basic video info
     * @param url Video url to parse
     * @param requestOptions Request options
     */
    static getVideo(url, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!url)
                throw new Error("Missing video url");
            if (url instanceof Video_1.default)
                url = url.url;
            const isValid = YouTube.validate(url, "VIDEO");
            if (!isValid)
                throw new Error("Invalid video url");
            const html = yield Util_1.default.getHTML(`${url}&hl=en`, requestOptions);
            return Util_1.default.getVideo(html);
        });
    }
    /**
     * Validates playlist
     * @param {string} url Playlist id or url/video id or url to validate
     * @param {"VIDEO"|"VIDEO_ID"|"PLAYLIST"|"PLAYLIST_ID"} type URL validation type
     * @returns {boolean}
     */
    static validate(url, type) {
        if (typeof url !== "string")
            return false;
        if (!type)
            type = "PLAYLIST";
        switch (type) {
            case "PLAYLIST":
                return YouTube.Regex.PLAYLIST_URL.test(url);
            case "PLAYLIST_ID":
                return YouTube.Regex.PLAYLIST_ID.test(url);
            case "VIDEO":
                return YouTube.Regex.VIDEO_URL.test(url);
            case "VIDEO_ID":
                return YouTube.Regex.VIDEO_ID.test(url);
            default:
                return false;
        }
    }
    static isPlaylist(src) {
        try {
            Util_1.default.validatePlaylist(src);
            return true;
        }
        catch (_a) {
            return false;
        }
    }
    static get Regex() {
        return {
            PLAYLIST_URL: Util_1.default.PlaylistURLRegex,
            PLAYLIST_ID: Util_1.default.PlaylistIDRegex,
            VIDEO_ID: Util_1.default.VideoIDRegex,
            VIDEO_URL: Util_1.default.VideoRegex
        };
    }
}
exports.YouTube = YouTube;
exports.default = YouTube;
